---
title: "Spike_and_slab_01"
output: html_document
---
Setup and load some data
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
setwd("~/Documents/AngSt/Semester_2/Advanced_R/asp21spike/R")
source("own_Gibbs_Mala.R")
source("own_helpers.R")
source("own_helpers_not_touched.R")
library(lmls)
library(invgamma)
library(MASS)
set.seed(234)

dat <- iris
dat$Species <- NULL
```

# First, simulate some data
```{r}
mu_S = c(1,2,3,4,5)
sigma_S = diag(1,nrow = 5,ncol = 5)
S = mvrnorm(n = 100,mu = mu_S,Sigma = sigma_S)

mu_N = c(10,11,12)
sigma_N = diag(1,nrow = 3,ncol = 3)
N = mvrnorm(n = 100,mu = mu_N,Sigma = sigma_N)

bets <- matrix(c(-2,6,3,-9,1))

y <- S %*% bets
y <- y + runif(100,0,0.00001) # add some noise to make lmls work

test_data <- cbind.data.frame(y,S,N)

names(test_data) <- c("y",paste0("s",1:5),paste0("n",1:3))
```


```{r Fit a lmsl regression model}

m <- lmls(y ~ s1 + s2 + s3 + s4 +s5 + n1 + n2 + n3 ,
          scale = ~ s1 + s2 + s5 + n1 + n2 + n3 - 1,
          data = test_data,
          light =FALSE)
```


```{r Initialise Hyperparameters}
v0 <- 0.01

hyper <- list(a_theta = setNames(c(0.5,0.5),c("location","scale")),
              b_theta = setNames(c(0.5,0.5),c("location","scale")),
              a_tau = setNames(c(1,1),c("location","scale")),
              b_tau = setNames(c(1,1),c("location","scale")))
```

Run the algorithm (i.e. step 5) starting from d)

```{r Initialise objects}
M <- 10000
stepsize <- 0.01
theta <- coefs <- tau <- delta <- list(location = matrix(NA,nrow = M,ncol = ncol(m$x)),
              scale = matrix(NA,nrow = M,ncol = ncol(m$z)))
m$tau <- list(location = NA,
              scale = NA)
```

```{r initialise parameters}

for(k in 1:2){
  n_params <- ncol(delta[[k]])
  theta[[k]][1,] <- rbeta(n_params,hyper$a_theta[k],hyper$b_theta[k])
  for(l in 1:n_params){
    delta[[k]][1,l] <- rbinom(1,1,theta[[k]][1,l])
    tau[[k]][1,l] <- sample_tau(delta[[k]][1,l],hyper$a_tau[k],hyper$b_tau[k],v0)
  }
  m$tau[[k]] <- tau[[k]][1,]

  param <- names(delta)[k]
  coefs[[k]][1,] <- coef(mmala_update(m,param,stepsize = stepsize))[[param]]
}
```

```{r update parameters}
for(mm in 2:M){
  for(kk in 1:2){
    n_params <- ncol(coefs[[kk]])
    
    for(ll in 1:n_params){
      ## update theta_lk
      # first make sure that we are using the most recent deltas
      current_delta <- delta[[kk]][mm,]
      current_delta[is.na(current_delta)] <- delta[[kk]][mm-1,is.na(current_delta)]
      theta[[kk]][mm,ll] <- update_theta(hyper$a_theta[kk],
                                         hyper$b_theta[kk],
                                         current_delta)
      # this makes sure that we always include the intercept in the model
      # the intercept is always assigned to the slab. However, this does not 
      # imply a flat prior --> need to incorporate.
      has_intercept <- "(Intercept)" %in% names(m$coefficients[[kk]])
      if(has_intercept){
        theta[[kk]][mm,1] <- 1
      }
      
      ## update delta_lk
      delta[[kk]][mm,ll] <- update_delta(theta = theta[[kk]][mm,ll],
                                         tau_j = tau[[kk]][mm-1,ll],
                                         a_tau = hyper$a_tau[kk],
                                         b_tau = hyper$b_tau[kk],
                                         v_0 = v0)
      
      ## update tau_lk
      tau[[kk]][mm,ll] <- update_tau(nsmp = 1,
                                     a_tau = hyper$a_tau[kk],
                                     b_tau = hyper$b_tau[kk],
                                     v_0 = v0,
                                     beta_j = coefs[[kk]][mm-1,ll],
                                     delta_j = delta[[kk]][mm,ll])
      ## update taus in the model
      # first extract most recent taus
      #current_taus <- tau[[k]][m,]
      #current_taus[is.na(current_taus)] <- tau[[k]][m-1,is.na(current_taus)]
      #m$tau[[k]] <- current_taus
      
      ## update the coefficients
      # first extract all most recent 
      
      #param <- names(delta)[kk]
      
    }
    
    ## update taus in the model
    # as of now this first samples all other parameters first and then samples 
    # the coefficients all together. However, it makes more sense to sample the
    # coefficient values within the loop. 
    m$tau[[kk]] <- tau[[kk]][mm,]
    # Lastly update coefficients
    param <- names(delta)[kk]
    m <- mmala_update(m,param,stepsize = stepsize)
    coefs[[kk]][mm,] <- coef(m)[[param]]
  }
}

```

```{r plot the results}
par(mfrow = c(3,3))
for(jj in 1:ncol(coefs$location)){
  hist(coefs$location[,jj],freq = F,breaks = 20)
}
colMeans(delta$location)

```

